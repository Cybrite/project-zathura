generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id           String   @id @default(uuid())
    email        String   @unique
    username     String   @unique
    password     String
    firstName    String?
    lastName     String?
    role         Role     @default(USER)
    refreshToken String?
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // HectoClash related fields
    rating       Int      @default(1200)
    gamesPlayed  Int      @default(0)
    gamesWon     Int      @default(0)

    // Relations to HectoClash
    hectocDuelsAsPlayerOne HectocDuel[] @relation("PlayerOne")
    hectocDuelsAsPlayerTwo HectocDuel[] @relation("PlayerTwo")
    hectocSolutions        HectocSolution[]
    hectocSpectating       HectocSpectator[]
    hectocChallenges       HectocChallenge[]

    sentRequests     FriendRequest[] @relation("SentRequests")
    receivedRequests FriendRequest[] @relation("ReceivedRequests")
     
     // Friendship relations
    friendsTo   Friendship[] @relation("UserFriends")
    friendsFrom Friendship[] @relation("FriendsUser")

    @@map("users")
}

model FriendRequest {
     id         String           @id @default(uuid())
     status     FriendshipStatus @default(PENDING)
     senderId   String
     receiverId String
     createdAt  DateTime         @default(now())
     updatedAt  DateTime         @updatedAt
 
     // Relations
     sender   User @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)
     receiver User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)
 
     @@unique([senderId, receiverId])
     @@map("friend_requests")
 }
 
 model Friendship {
     id        String   @id @default(uuid())
     userId    String
     friendId  String
     createdAt DateTime @default(now())
 
     // Relations
     user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
     friend User @relation("FriendsUser", fields: [friendId], references: [id], onDelete: Cascade)
 
     @@unique([userId, friendId])
     @@map("friendships")
 }

enum Role {
    USER
    ADMIN
}

enum FriendshipStatus {
     PENDING
     ACCEPTED
     REJECTED
 }

// HectoClash Models

model HectocDuel {
    id                String         @id @default(uuid())
    createdAt         DateTime       @default(now())
    startedAt         DateTime?
    endedAt           DateTime?
    status            HectocDuelStatus @default(WAITING)
    
    // Players
    playerOneId       String
    playerOne         User           @relation("PlayerOne", fields: [playerOneId], references: [id])
    playerTwoId       String?
    playerTwo         User?          @relation("PlayerTwo", fields: [playerTwoId], references: [id])
    
    // Game data
    digits            Int[]          // The 6 digits for this puzzle
    target            Int            @default(100)
    difficulty        String         // easy, medium, hard, expert
    
    // Results
    winnerId          String?
    playerOneFinishedAt DateTime?
    playerTwoFinishedAt DateTime?
    
    // Relations
    spectators        HectocSpectator[]
    solutions         HectocSolution[]

    @@map("hectoc_duels")
    @@index([playerOneId])
    @@index([playerTwoId])
    @@index([status])
}

model HectocSolution {
    id               String     @id @default(uuid())
    createdAt        DateTime   @default(now())
    
    // User who submitted the solution
    userId           String
    user             User       @relation(fields: [userId], references: [id])
    
    // Duel this solution belongs to
    duelId           String
    duel             HectocDuel @relation(fields: [duelId], references: [id])
    
    // Solution data
    expression       String     // The actual solution expression
    isCorrect        Boolean
    timeToSolve      Int        // Time in milliseconds
    
    @@map("hectoc_solutions")
    @@index([userId])
    @@index([duelId])
}

model HectocSpectator {
    id               String     @id @default(uuid())
    
    // User who is spectating
    userId           String
    user             User       @relation(fields: [userId], references: [id])
    
    // Duel being spectated
    duelId           String
    duel             HectocDuel @relation(fields: [duelId], references: [id])
    
    joinedAt         DateTime   @default(now())
    
    @@map("hectoc_spectators")
    @@unique([duelId, userId])
}

model HectocChallenge {
    id               String     @id @default(uuid())
    createdAt        DateTime   @default(now())
    
    // User who sent the challenge
    challengerId     String
    challenger       User       @relation(fields: [challengerId], references: [id])
    
    // Challenge configuration
    difficulty       String?    // Specific difficulty or null for random
    message          String?    
    expiresAt        DateTime
    status           HectocChallengeStatus @default(PENDING)
    
    @@map("hectoc_challenges")
    @@index([challengerId])
    @@index([status])
}

enum HectocDuelStatus {
    WAITING
    IN_PROGRESS
    FINISHED
    CANCELLED
}

enum HectocChallengeStatus {
    PENDING
    ACCEPTED
    REJECTED
    EXPIRED
}
